<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2016-12-02 周五 14:51 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="viewport" content="width=device-width, initial-scale=1" />
<title>Tear Engine</title>
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="keyring" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="http://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.js"></script>
<script type="text/javascript" src="http://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Tear Engine</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline13">Build a project</a>
<ul>
<li><a href="#orgheadline1">Why need an engine</a></li>
<li><a href="#orgheadline2">Choice</a></li>
<li><a href="#orgheadline11">Create engine core lib</a>
<ul>
<li><a href="#orgheadline5">install dependence</a></li>
<li><a href="#orgheadline6">window framework</a></li>
<li><a href="#orgheadline9">engine framework</a></li>
<li><a href="#orgheadline10">engine lib</a></li>
</ul>
</li>
<li><a href="#orgheadline12">Test</a></li>
</ul>
</li>
<li><a href="#orgheadline14">Rendering</a>
<ul>
<li><a href="#orgheadline15">图形API</a></li>
<li><a href="#orgheadline16">使用 OpenGL/OpenGL ES</a>
<ul>
<li><a href="#orgheadline17">GLEW（桌面）</a></li>
<li><a href="#orgheadline19">EGL（移动）</a></li>
</ul>
</li>
<li><a href="#orgheadline20">绘制一个三角形</a>
<ul>
<li><a href="#orgheadline21">Pipeline</a></li>
<li><a href="#orgheadline22">可编程着色器</a></li>
</ul>
</li>
<li><a href="#orgheadline23">纹理</a></li>
</ul>
</li>
<li><a href="#orgheadline24">Main Loop</a></li>
<li><a href="#orgheadline25">Sprite</a>
<ul>
<li><a href="#orgheadline26">2D投影</a></li>
<li><a href="#orgheadline27">SpriteRenderer</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline13" class="outline-2">
<h2 id="orgheadline13">Build a project</h2>
<div class="outline-text-2" id="text-orgheadline13">
</div><div id="outline-container-orgheadline1" class="outline-3">
<h3 id="orgheadline1">Why need an engine</h3>
<div class="outline-text-3" id="text-orgheadline1">
<p>
   为什么要专门开发游戏引擎？为什么要使用游戏引擎来开发游戏？游戏引擎的优势在哪？
简言之：开发游戏不是绝对需要引擎的。但这建立在两个基础上，1）这个游戏很简单，2）你在过往的项目中积累了大量的代码。
游戏引擎本质上就是一堆游戏开发库，用来节省游戏开发的时间。使用统一的引擎，利于团队在统一的标准上开发游戏，节约团队开发时间；引擎跨平台，节约游戏移植时间；游戏逻辑与基础功能分离，开发效率更高。
</p>
</div>
</div>

<div id="outline-container-orgheadline2" class="outline-3">
<h3 id="orgheadline2">Choice</h3>
<div class="outline-text-3" id="text-orgheadline2">

<div class="figure">
<p><img src="./images/tear_1.png" alt="tear_1.png" />
</p>
</div>

<p>
   引擎只是一个框架，一个库，所以实现方式多样，技术选型也受多方面影响。比如语言方面，c,c++,c#,java,python等等都有，然后是硬件平台，PC，MAC，移动，主机等等，还有系统，windows，linux，macos，ios，android，xbox，ps4等等。
这里，我的开发选择是用C++开发一个跨平台引擎，至少支持windows和linux。使用emacs编辑，premake其他工程文件。
</p>
</div>
</div>

<div id="outline-container-orgheadline11" class="outline-3">
<h3 id="orgheadline11">Create engine core lib</h3>
<div class="outline-text-3" id="text-orgheadline11">
</div><div id="outline-container-orgheadline5" class="outline-4">
<h4 id="orgheadline5">install dependence</h4>
<div class="outline-text-4" id="text-orgheadline5">
</div><ul class="org-ul"><li><a id="orgheadline3"></a>glfw3<br  /><div class="outline-text-5" id="text-orgheadline3">
<ul class="org-ul">
<li>linux/macos
<ol class="org-ol">
<li>sudo apt-get install cmake xorg-dev</li>
<li>git clone <a href="https://github.com/glfw/glfw.git">https://github.com/glfw/glfw.git</a></li>
<li>cd glfw</li>
<li>mkdir build</li>
<li>cd build</li>
<li>cmake ../</li>
<li>make &amp;&amp; sudo make install</li>
</ol></li>

<li>windows
<ol class="org-ol">
<li>go to <a href="http://www.glfw.org/download.html">http://www.glfw.org/download.html</a></li>
<li>download windows pre-compiled binary and unpack</li>
<li>go to your visual studio installed path, in VC folder</li>
<li>put <i>GLFW</i> to include folder, <i>glfw3.lib glfw3dll.lib</i> to lib folder, <i>glfw3.dll</i> to bin folder</li>
</ol></li>
</ul>
</div></li>

<li><a id="orgheadline4"></a>premake<br  /><div class="outline-text-5" id="text-orgheadline4">
<p>
为了管理不同平台的工程文件，我们采用premake构建工具，它与cmake类似，但用lua代码进行配置。
</p>
</div></li></ul>
</div>

<div id="outline-container-orgheadline6" class="outline-4">
<h4 id="orgheadline6">window framework</h4>
<div class="outline-text-4" id="text-orgheadline6">
<p>
游戏引擎为游戏服务。游戏运行于操作系统上，它首先是应用程序，然后才是游戏。所以，游戏首先需要的是用于展示内容的“窗口”。窗口在不同的操作系统上有不同的称呼，所以建立窗口的方式也是操作系统强相关的。
这里我采用 <b>GLFW</b> 库来简化窗口的创建。
</p>
</div>

<ul class="org-ul"><li><a id="orgheadline7"></a>create a window<br  /><div class="outline-text-5" id="text-orgheadline7">
<p>
现在我们使用glfw，用最少的代码创建一个空窗口。
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;GLFW/glfw3.h&gt;</span>

<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;stdlib.h&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;stdio.h&gt;</span>

<span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">error_callback</span><span style="color: #4f97d7;">(</span><span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">error</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">char</span> *<span style="color: #7590db;">description</span><span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">{</span>
  fprintf<span style="color: #bc6ec5;">(</span>stderr, <span style="color: #2d9574;">"TxxE Error: %s\n"</span>, description<span style="color: #bc6ec5;">)</span>;
<span style="color: #4f97d7;">}</span>

<span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">key_callback</span><span style="color: #4f97d7;">(</span><span style="color: #ce537a; font-weight: bold;">GLFWwindow</span> *<span style="color: #7590db;">window</span>, <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">key</span>, <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">scancode</span>, <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">action</span>, <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">mods</span><span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">{</span>
  <span style="color: #4f97d7; font-weight: bold;">if</span><span style="color: #bc6ec5;">(</span>key == GLFW_KEY_ESCAPE &amp;&amp; action == GLFW_PRESS<span style="color: #bc6ec5;">){</span>
    glfwSetWindowShouldClose<span style="color: #2d9574;">(</span>window, GLFW_TRUE<span style="color: #2d9574;">)</span>;
  <span style="color: #bc6ec5;">}</span>
<span style="color: #4f97d7;">}</span>


<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #bc6ec5; font-weight: bold;">main</span><span style="color: #4f97d7;">(</span><span style="color: #ce537a; font-weight: bold;">void</span><span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">{</span>

  glfwSetErrorCallback<span style="color: #bc6ec5;">(</span>error_callback<span style="color: #bc6ec5;">)</span>;
  <span style="color: #4f97d7; font-weight: bold;">if</span><span style="color: #bc6ec5;">(</span><span style="color: #a45bad;">!</span>glfwInit<span style="color: #2d9574;">()</span><span style="color: #bc6ec5;">){</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> -<span style="color: #a45bad;">1</span>;
  <span style="color: #bc6ec5;">}</span>

  <span style="color: #ce537a; font-weight: bold;">GLFWwindow</span> *<span style="color: #7590db;">window</span> = glfwCreateWindow<span style="color: #bc6ec5;">(</span><span style="color: #a45bad;">800</span>, <span style="color: #a45bad;">600</span>, <span style="color: #2d9574;">"Txx"</span>, <span style="color: #a45bad;">NULL</span>, <span style="color: #a45bad;">NULL</span><span style="color: #bc6ec5;">)</span>;
  <span style="color: #4f97d7; font-weight: bold;">if</span><span style="color: #bc6ec5;">(</span><span style="color: #a45bad;">!</span>window<span style="color: #bc6ec5;">){</span>
    glfwTerminate<span style="color: #2d9574;">()</span>;
    <span style="color: #4f97d7; font-weight: bold;">return</span> -<span style="color: #a45bad;">1</span>;
  <span style="color: #bc6ec5;">}</span>

  glfwSetKeyCallback<span style="color: #bc6ec5;">(</span>window, key_callback<span style="color: #bc6ec5;">)</span>;

    <span style="color: #4f97d7; font-weight: bold;">while</span><span style="color: #bc6ec5;">(</span><span style="color: #a45bad;">!</span>glfwWindowShouldClose<span style="color: #2d9574;">(</span>window<span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">){</span>
      glClear<span style="color: #2d9574;">(</span>GL_COLOR_BUFFER_BIT<span style="color: #2d9574;">)</span>;

      glfwSwapBuffers<span style="color: #2d9574;">(</span>window<span style="color: #2d9574;">)</span>;

      glfwPollEvents<span style="color: #2d9574;">()</span>;
    <span style="color: #bc6ec5;">}</span>

    glfwDestroyWindow<span style="color: #bc6ec5;">(</span>window<span style="color: #bc6ec5;">)</span>;
    glfwTerminate<span style="color: #bc6ec5;">()</span>;
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">0</span>;
<span style="color: #4f97d7;">}</span>
</pre>
</div>
</div></li>

<li><a id="orgheadline8"></a>build a application<br  /><div class="outline-text-5" id="text-orgheadline8">
<p>
在ubuntu上快速编译运行一下。
</p>
<div class="org-src-container">

<pre class="src src-shell">g++ main.cpp -lglfw3 -lX11 -lXrandr -lXinerama -lXi -lXxf86vm -lXcursor -lGL -lpthread -ldl
</pre>
</div>

<p>
稍微正常的人都不会愿意每次编译都写上这么一段，所以makefile文件是必须的。而为了跨平台，又需要一个能一键生成各个平台的工程文件。所以我们使用premake来生成各个平台的工程文件。配置信息见 premake5.lua。
</p>
</div></li></ul>
</div>
<div id="outline-container-orgheadline9" class="outline-4">
<h4 id="orgheadline9">engine framework</h4>
<div class="outline-text-4" id="text-orgheadline9">
<p>
游戏最基本的运行逻辑， <b>加载</b> ， <b>初始化</b> ， <b>更新</b> ， <b>结束</b> 。我们的引擎会在必要的时候调用这四个操作来驱动游戏运行。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #4f97d7; font-weight: bold;">extern</span> <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">game_load</span><span style="color: #4f97d7;">()</span>;
<span style="color: #4f97d7; font-weight: bold;">extern</span> <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">game_init</span><span style="color: #4f97d7;">()</span>;
<span style="color: #4f97d7; font-weight: bold;">extern</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">game_update</span><span style="color: #4f97d7;">()</span>;
<span style="color: #4f97d7; font-weight: bold;">extern</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">game_end</span><span style="color: #4f97d7;">()</span>;
</pre>
</div>

<p>
所有基于本引擎的游戏必须实现这四个函数。
</p>
</div>
</div>

<div id="outline-container-orgheadline10" class="outline-4">
<h4 id="orgheadline10">engine lib</h4>
<div class="outline-text-4" id="text-orgheadline10">
<p>
现在我们来将引擎做成一个库，真正的游戏就建立在这个库之上。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Tear.h</span>
<span style="color: #bc6ec5;">#if</span><span style="color: #bc6ec5;">n</span><span style="color: #bc6ec5;">def</span> __TEAR_H__
<span style="color: #bc6ec5;">#define</span> <span style="color: #7590db;">__TEAR_H__</span>

<span style="color: #4f97d7; font-weight: bold;">extern</span> <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">game_load</span><span style="color: #4f97d7;">()</span>;
<span style="color: #4f97d7; font-weight: bold;">extern</span> <span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">game_init</span><span style="color: #4f97d7;">()</span>;
<span style="color: #4f97d7; font-weight: bold;">extern</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">game_update</span><span style="color: #4f97d7;">()</span>;
<span style="color: #4f97d7; font-weight: bold;">extern</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">game_end</span><span style="color: #4f97d7;">()</span>;

<span style="color: #4f97d7; font-weight: bold;">namespace</span> <span style="color: #a45bad;">Tear</span><span style="color: #4f97d7;">{</span>
    <span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">Engine</span><span style="color: #bc6ec5;">{</span>
        <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">m_window_width</span>;
        <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">m_window_height</span>;

    <span style="color: #4f97d7; font-weight: bold;">public</span>:
        <span style="color: #bc6ec5; font-weight: bold;">Engine</span><span style="color: #2d9574;">()</span>;
        ~<span style="color: #bc6ec5; font-weight: bold;">Engine</span><span style="color: #2d9574;">()</span>;

        <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #bc6ec5; font-weight: bold;">init</span><span style="color: #2d9574;">(</span><span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">width</span>, <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">height</span><span style="color: #2d9574;">)</span>;
        <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">update</span><span style="color: #2d9574;">()</span>;
        <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">close</span><span style="color: #2d9574;">()</span>;


        <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #bc6ec5; font-weight: bold;">getWindowWidth</span><span style="color: #2d9574;">(){</span> <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #4f97d7; font-weight: bold;">this</span>-&gt;m_window_width; <span style="color: #2d9574;">}</span>
        <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">setWindowWidth</span><span style="color: #2d9574;">(</span><span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">value</span><span style="color: #2d9574;">){</span> <span style="color: #4f97d7; font-weight: bold;">this</span>-&gt;m_window_width = value; <span style="color: #2d9574;">}</span>
        <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #bc6ec5; font-weight: bold;">getWindowHeight</span><span style="color: #2d9574;">(){</span> <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #4f97d7; font-weight: bold;">this</span>-&gt;m_window_height; <span style="color: #2d9574;">}</span>
        <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">setWindowHeight</span><span style="color: #2d9574;">(</span><span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">value</span><span style="color: #2d9574;">){</span> <span style="color: #4f97d7; font-weight: bold;">this</span>-&gt;m_window_height = value; <span style="color: #2d9574;">}</span>
    <span style="color: #bc6ec5;">}</span>;
<span style="color: #4f97d7;">}</span>;

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">global engine object</span>
<span style="color: #4f97d7; font-weight: bold;">extern</span> <span style="color: #a45bad;">Tear</span>::<span style="color: #ce537a; font-weight: bold;">Engine</span> *<span style="color: #7590db;">g_tear_engine</span>;
<span style="color: #bc6ec5;">#endif</span>
</pre>
</div>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Tear.cpp</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">"Tear.h"</span>

<span style="color: #4f97d7; font-weight: bold;">namespace</span> <span style="color: #a45bad;">Tear</span><span style="color: #4f97d7;">{</span>
    <span style="color: #a45bad;">Engine</span>::<span style="color: #bc6ec5; font-weight: bold;">Engine</span><span style="color: #bc6ec5;">()</span>:m_window_width<span style="color: #bc6ec5;">(</span><span style="color: #a45bad;">800</span><span style="color: #bc6ec5;">)</span>,
                     m_window_height<span style="color: #bc6ec5;">(</span><span style="color: #a45bad;">600</span><span style="color: #bc6ec5;">)</span>
    <span style="color: #bc6ec5;">{</span>
    <span style="color: #bc6ec5;">}</span>

    <span style="color: #a45bad;">Engine</span>::~<span style="color: #bc6ec5; font-weight: bold;">Engine</span><span style="color: #bc6ec5;">()</span>
    <span style="color: #bc6ec5;">{</span>
    <span style="color: #bc6ec5;">}</span>

    <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #a45bad;">Engine</span>::<span style="color: #bc6ec5; font-weight: bold;">init</span><span style="color: #bc6ec5;">(</span><span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">width</span>, <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">height</span><span style="color: #bc6ec5;">)</span>
    <span style="color: #bc6ec5;">{</span>
        <span style="color: #4f97d7; font-weight: bold;">if</span><span style="color: #2d9574;">(</span><span style="color: #a45bad;">!</span>game_init<span style="color: #67b11d;">()</span><span style="color: #2d9574;">){</span>
            <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">0</span>;
        <span style="color: #2d9574;">}</span>

        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">1</span>;
    <span style="color: #bc6ec5;">}</span>

    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #a45bad;">Engine</span>::<span style="color: #bc6ec5; font-weight: bold;">update</span><span style="color: #bc6ec5;">()</span>
    <span style="color: #bc6ec5;">{</span>
        game_update<span style="color: #2d9574;">()</span>;
    <span style="color: #bc6ec5;">}</span>

    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #a45bad;">Engine</span>::<span style="color: #bc6ec5; font-weight: bold;">close</span><span style="color: #bc6ec5;">()</span>
    <span style="color: #bc6ec5;">{</span>
        game_end<span style="color: #2d9574;">()</span>;
    <span style="color: #bc6ec5;">}</span>
<span style="color: #4f97d7;">}</span>
</pre>
</div>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">main.cpp</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">"Tear.h"</span>

<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;GLFW/glfw3.h&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;cstdlib&gt;</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">&lt;cstdio&gt;</span>

<span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">error_callback</span><span style="color: #4f97d7;">(</span><span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">error</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">char</span> *<span style="color: #7590db;">description</span><span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">{</span>
    fprintf<span style="color: #bc6ec5;">(</span>stderr, <span style="color: #2d9574;">"glfw Error: %s\n"</span>, description<span style="color: #bc6ec5;">)</span>;
<span style="color: #4f97d7;">}</span>

<span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">key_callback</span><span style="color: #4f97d7;">(</span><span style="color: #ce537a; font-weight: bold;">GLFWwindow</span> *<span style="color: #7590db;">window</span>, <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">key</span>, <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">scancode</span>, <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">action</span>, <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">mods</span><span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">{</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span><span style="color: #bc6ec5;">(</span>key == GLFW_KEY_ESCAPE &amp;&amp; action == GLFW_PRESS<span style="color: #bc6ec5;">){</span>
        glfwSetWindowShouldClose<span style="color: #2d9574;">(</span>window, GLFW_TRUE<span style="color: #2d9574;">)</span>;
    <span style="color: #bc6ec5;">}</span>

<span style="color: #4f97d7;">}</span>

<span style="color: #a45bad;">Tear</span>::<span style="color: #ce537a; font-weight: bold;">Engine</span> *<span style="color: #7590db;">g_tear_engine</span>;

<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #bc6ec5; font-weight: bold;">main</span><span style="color: #4f97d7;">(</span><span style="color: #ce537a; font-weight: bold;">void</span><span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">{</span>
    glfwSetErrorCallback<span style="color: #bc6ec5;">(</span>error_callback<span style="color: #bc6ec5;">)</span>;
    <span style="color: #4f97d7; font-weight: bold;">if</span><span style="color: #bc6ec5;">(</span><span style="color: #a45bad;">!</span>glfwInit<span style="color: #2d9574;">()</span><span style="color: #bc6ec5;">){</span>
        <span style="color: #4f97d7; font-weight: bold;">return</span> -<span style="color: #a45bad;">1</span>;
    <span style="color: #bc6ec5;">}</span>

    g_tear_engine = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #a45bad;">Tear</span>::<span style="color: #ce537a; font-weight: bold;">Engine</span><span style="color: #bc6ec5;">()</span>;

    <span style="color: #4f97d7; font-weight: bold;">if</span><span style="color: #bc6ec5;">(</span><span style="color: #a45bad;">!</span>game_load<span style="color: #2d9574;">()</span><span style="color: #bc6ec5;">){</span>
        fprintf<span style="color: #2d9574;">(</span>stderr, <span style="color: #2d9574;">"game load fail\n"</span><span style="color: #2d9574;">)</span>;
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">0</span>;
    <span style="color: #bc6ec5;">}</span>

    glfwWindowHint<span style="color: #bc6ec5;">(</span>GLFW_CONTEXT_VERSION_MAJOR, <span style="color: #a45bad;">3</span><span style="color: #bc6ec5;">)</span>;
    glfwWindowHint<span style="color: #bc6ec5;">(</span>GLFW_CONTEXT_VERSION_MINOR, <span style="color: #a45bad;">3</span><span style="color: #bc6ec5;">)</span>;
    glfwWindowHint<span style="color: #bc6ec5;">(</span>GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE<span style="color: #bc6ec5;">)</span>;
    glfwWindowHint<span style="color: #bc6ec5;">(</span>GLFW_RESIZABLE, GL_FALSE<span style="color: #bc6ec5;">)</span>;

    <span style="color: #ce537a; font-weight: bold;">GLFWwindow</span> *<span style="color: #7590db;">window</span> = glfwCreateWindow<span style="color: #bc6ec5;">(</span>g_tear_engine-&gt;getWindowWidth<span style="color: #2d9574;">()</span>, g_tear_engine-&gt;getWindowHeight<span style="color: #2d9574;">()</span>, <span style="color: #2d9574;">"Tear Engine"</span>, nullptr, nullptr<span style="color: #bc6ec5;">)</span>;
    <span style="color: #4f97d7; font-weight: bold;">if</span><span style="color: #bc6ec5;">(</span><span style="color: #a45bad;">!</span>window<span style="color: #bc6ec5;">){</span>
        fprintf<span style="color: #2d9574;">(</span>stderr, <span style="color: #2d9574;">"Failed to open GLFW window\n"</span><span style="color: #2d9574;">)</span>;
        glfwTerminate<span style="color: #2d9574;">()</span>;
        <span style="color: #4f97d7; font-weight: bold;">return</span> -<span style="color: #a45bad;">1</span>;
    <span style="color: #bc6ec5;">}</span>

    glfwSetKeyCallback<span style="color: #bc6ec5;">(</span>window, key_callback<span style="color: #bc6ec5;">)</span>;

    <span style="color: #4f97d7; font-weight: bold;">if</span><span style="color: #bc6ec5;">(</span><span style="color: #a45bad;">!</span>g_tear_engine-&gt;init<span style="color: #2d9574;">(</span>g_tear_engine-&gt;getWindowWidth<span style="color: #67b11d;">()</span>, g_tear_engine-&gt;getWindowHeight<span style="color: #67b11d;">()</span><span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">){</span>
        fprintf<span style="color: #2d9574;">(</span>stderr, <span style="color: #2d9574;">"game engine init fail\n"</span><span style="color: #2d9574;">)</span>;
        <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">0</span>;
    <span style="color: #bc6ec5;">}</span>


    <span style="color: #4f97d7; font-weight: bold;">while</span> <span style="color: #bc6ec5;">(</span><span style="color: #a45bad;">!</span>glfwWindowShouldClose<span style="color: #2d9574;">(</span>window<span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">){</span>

        glfwPollEvents<span style="color: #2d9574;">()</span>;

        g_tear_engine-&gt;update<span style="color: #2d9574;">()</span>;

        glfwSwapBuffers<span style="color: #2d9574;">(</span>window<span style="color: #2d9574;">)</span>;

    <span style="color: #bc6ec5;">}</span>
    g_tear_engine-&gt;close<span style="color: #bc6ec5;">()</span>;
    <span style="color: #4f97d7; font-weight: bold;">delete</span> g_tear_engine;

    glfwDestroyWindow<span style="color: #bc6ec5;">(</span>window<span style="color: #bc6ec5;">)</span>;
    glfwTerminate<span style="color: #bc6ec5;">()</span>;

    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">0</span>;
<span style="color: #4f97d7;">}</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline12" class="outline-3">
<h3 id="orgheadline12">Test</h3>
<div class="outline-text-3" id="text-orgheadline12">
<p>
引擎已经弄好，现在来写一个游戏吧。
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">example_01.cpp</span>
<span style="color: #bc6ec5;">#include</span> <span style="color: #2d9574;">"Tear.h"</span>

<span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">game_load</span><span style="color: #4f97d7;">()</span>
<span style="color: #4f97d7;">{</span>
    g_tear_engine-&gt;setWindowWidth<span style="color: #bc6ec5;">(</span><span style="color: #a45bad;">640</span><span style="color: #bc6ec5;">)</span>;
    g_tear_engine-&gt;setWindowHeight<span style="color: #bc6ec5;">(</span><span style="color: #a45bad;">480</span><span style="color: #bc6ec5;">)</span>;
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">true</span>;
<span style="color: #4f97d7;">}</span>

<span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #bc6ec5; font-weight: bold;">game_init</span><span style="color: #4f97d7;">()</span>
<span style="color: #4f97d7;">{</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> <span style="color: #a45bad;">true</span>;
<span style="color: #4f97d7;">}</span>

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">game_update</span><span style="color: #4f97d7;">()</span>
<span style="color: #4f97d7;">{</span>

<span style="color: #4f97d7;">}</span>

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">game_end</span><span style="color: #4f97d7;">()</span>
<span style="color: #4f97d7;">{</span>

<span style="color: #4f97d7;">}</span>
</pre>
</div>


<p>
运行成功后会出现一个黑色的窗口，这一次的窗口已经不再是纯粹的窗口了。它本质上已经变成了通过引擎驱动起来的游戏。通过在上述四个game<sub>xx函数里不断添加游戏逻辑</sub>，就能产生不同的游戏。
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline14" class="outline-2">
<h2 id="orgheadline14">Rendering</h2>
<div class="outline-text-2" id="text-orgheadline14">
<p>
游戏最重要的元素当属视觉效果，毕竟人类70%的信息获取也是视觉提供的。游戏的画面在图形学中称为 <b>渲染（Rendering）</b> 。
游戏引擎在窗口支持之后的第一要务就是图形渲染支持。
</p>
</div>

<div id="outline-container-orgheadline15" class="outline-3">
<h3 id="orgheadline15">图形API</h3>
<div class="outline-text-3" id="text-orgheadline15">
<p>
我们要在窗口上画图，做渲染，离不开硬件的支持。最简单的画图就是直接往显示器内存写像素值。而今，随着技术的发展，GPU的普及，绘图的工作
基本由GPU负责。为了避免直接操作硬件，从而抽象出各类图形API，提高绘图的开发效率。下面是当前主流的几个图形API。
</p>
<ul class="org-ul">
<li>OpenGL： 传承自SGI，最早的专用图形API，属于开放性标准。因为跨平台，多用于专业领域，游戏领域甚少使用。</li>
<li>Direc3D： 微软私有标准，仅限于windows，XBOX,winphone平台。桌面图形API的霸主，设计精良，效率一流，桌面游戏开发的不二之选。</li>
<li>OpenGL ES： 精简版 OpenGL，专为小型嵌入式设备设计。因移动平台崛起而风靡。</li>
<li>Metal： 苹果自家最新私有标准，为改良OpenGL ES诞生。</li>
<li>Vulkan： 下一代 OpenGL 标准，统一桌面移动两种 GL，降低驱动层消耗，最大化利用硬件能力。</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline16" class="outline-3">
<h3 id="orgheadline16">使用 OpenGL/OpenGL ES</h3>
<div class="outline-text-3" id="text-orgheadline16">
<p>
由于当前移动游戏崛起，以前不受游戏开发待见的OpenGL因为跨平台性焕发了第二春。所以，我们的游戏引擎的图形API支持就从OpenGL
开始。
</p>
</div>
<div id="outline-container-orgheadline17" class="outline-4">
<h4 id="orgheadline17">GLEW（桌面）</h4>
<div class="outline-text-4" id="text-orgheadline17">
<p>
同前面所使用的glfw类似，glew是简化使用OpenGL的一个库。因为OpenGL只是一个标准/规范，具体的实现是由驱动开发商针对特定显卡实现的。由于OpenGL驱动版本众多，它大多数函数的位置都无法在编译时确定下来，需要在运行时查询。任务就落在了开发者身上，开发者需要在运行时获取函数地址并将其保存在一个函数指针中供以后使用。一般这步操作由操作系统实现。但OpenGL当前版本已经到了4.x（终止开发，转向vulkan），而部分操作系统没有及时支持高版本的API。其中最狠的就是windows上，只支持最古老的OpenGL1.1。所以我们需要绕过操作系统，在运行时查询函数地址直接使用显卡提供的高版本API。而取函数地址的方式因平台各异，所以GLEW封装了这层操作，向上提供纯粹的OpenGL接口，隐藏平台差异，版本差异，简化使用GL。
</p>
</div>

<ul class="org-ul"><li><a id="orgheadline18"></a>install<br  /><div class="outline-text-5" id="text-orgheadline18">
<ul class="org-ul">
<li>linux
<ol class="org-ol">
<li>git clone <a href="https://github.com/nigels-com/glew.git">https://github.com/nigels-com/glew.git</a> glew</li>
<li>cd glew/auto</li>
<li>make</li>
<li>cd ..</li>
<li>sudo make install</li>
</ol></li>

<li>windows
<ol class="org-ol">
<li>download pre-binary</li>
</ol></li>
</ul>
</div></li></ul>
</div>



<div id="outline-container-orgheadline19" class="outline-4">
<h4 id="orgheadline19">EGL（移动）</h4>
<div class="outline-text-4" id="text-orgheadline19">
<p>
移动端使用OpenGLES，但GLES本身只是一个操作GPU的API，不具备与平台Native层交互的能力。EGL因此而生——作为GLES与Native窗口的桥梁。EGL 是 OpenGL ES（嵌入式）和底层 Native 平台视窗系统之间的接口。EGL API 是独立于OpenGL ES各版本标准的独立API ，其主要作用是为OpenGL指令创建 Context 、绘制目标Surface 、配置Framebuffer属性、Swap提交绘制结果等。
此外，EGL为GPU厂商和OS窗口系统之间提供了一个标准配置接口。一般移动操作系统对GLES的支持非常及时，所以GLEW就不是很必要了。
对于android，可以使用SDK提供的GLSurfaceView简化开发。对于ios，为了适应cocoa框架，苹果做了一点修改，叫EAGL。具体使用参阅各自平台的文档。
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline20" class="outline-3">
<h3 id="orgheadline20">绘制一个三角形</h3>
<div class="outline-text-3" id="text-orgheadline20">
<p>
使用OpenGL绘制一个三角形应该是“Hello World”级别的GL程序。
</p>
</div>

<div id="outline-container-orgheadline21" class="outline-4">
<h4 id="orgheadline21">Pipeline</h4>
<div class="outline-text-4" id="text-orgheadline21">
<p>
OpenGL是一个3D图形API，所以其中任何事物都位于2D空间中。而我们接受输出的对象（窗口、屏幕）却是2D的。所以整个OpenGL的大部分工作就是将3D世界转化为2D像素数组。这个流程叫 <b>图形流水线（Graphics Pipeline）</b> ，一堆原始的三维图形数据，经过流水线各个阶段的处理，最终输出显示在屏幕上。
</p>


<div class="figure">
<p><img src="./images/pipeline.png" alt="pipeline.png" />
</p>
</div>

<p>
就像工厂里的流水线一样，渲染流水线也分多个阶段，每个阶段接收上个阶段的输出作为输入，然后向后输出相应的数据。每一个阶段拆分的足够模块化，使得任务可以高度并行。同时，GPU本身是个多处理器架构，一个GPU可能同时包含上千的流处理器核心。每个核心运行 <b>shader（着色器）</b> ，处理传入的数据，互不干扰。
流水线中的一部分允许开发者直接控制，意味着这些阶段GPU核心可以运行开发者自己写的shader。这样的好处在于，对于渲染结果，开发者可以进行更细致的控制。
</p>
</div>
</div>

<div id="outline-container-orgheadline22" class="outline-4">
<h4 id="orgheadline22">可编程着色器</h4>
<div class="outline-text-4" id="text-orgheadline22">
<p>
可编程着色器指的就是可以由开发者自己编写的着色器，也就是平时说的写shader。与之对应的就是固定着色器，也叫默认着色器，开发者不能用自己的shader替换，只能通过API进行开关控制。
现代图形API基本都要求开发者至少提供一个 <b>顶点着色器（vertex shader）</b> 和一个 <b>片段着色器（fragment shader）</b> 。（其他API可能名字不同，比如D3D里叫顶点着色器和像素着色器。）为什么要必须提供呢，因为图形API对这两个阶段没有提供默认shader了，所以需要开发者提供。下面提供两个最基础的着色器。
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">vs</span>
<span style="color: #bc6ec5;">#version</span> <span style="color: #a45bad;">330</span> core

layout <span style="color: #4f97d7;">(</span>location = <span style="color: #a45bad;">0</span><span style="color: #4f97d7;">)</span> in <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">position</span>;

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">main</span><span style="color: #4f97d7;">()</span>
<span style="color: #4f97d7;">{</span>
    gl_Position = vec4<span style="color: #bc6ec5;">(</span>position.x, position.y, position.z, <span style="color: #a45bad;">1.0</span><span style="color: #bc6ec5;">)</span>;
<span style="color: #4f97d7;">}</span>
</pre>
</div>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">fs</span>
<span style="color: #bc6ec5;">#version</span> <span style="color: #a45bad;">330</span> core

out <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">color</span>;

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">main</span><span style="color: #4f97d7;">()</span>
<span style="color: #4f97d7;">{</span>
    color = vec4<span style="color: #bc6ec5;">(</span><span style="color: #a45bad;">1.0f</span>, <span style="color: #a45bad;">0.5f</span>, <span style="color: #a45bad;">0.2f</span>, <span style="color: #a45bad;">1.0f</span><span style="color: #bc6ec5;">)</span>;
<span style="color: #4f97d7;">}</span>
</pre>
</div>

<p>
掌握渲染流水线和可编程着色器两个概念，然后配合OpenGL提供的API，就可以绘制出你的第一个一个三角形。对于移动端，可参阅网上的资料，搜索关键字 <b>EGL, OpenGLES, 三角形</b> 。
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline23" class="outline-3">
<h3 id="orgheadline23">纹理</h3>
<div class="outline-text-3" id="text-orgheadline23">
<p>
图形由顶点构成，图形的颜色也由顶点的颜色决定。我们为每个顶点设置颜色之后，其他非顶点位置的颜色则是自动插值出来的。理论上，你可以设置足够密集的顶点（与像素点一样多），然后为每个顶点逐一设置一个颜色，就可以表现出足够细节的图形。但很明显，这种办法太麻烦，额外需求太高。
 <b>纹理（Texture）</b> 应运而生。纹理一般作为2D图片出现（1D,3D的也有），用来映射到图形上添加图形的细节。只需指定有限的映射点，即可生成足够的细节。
</p>


<div class="figure">
<p><img src="./images/tex_coords.png" alt="tex_coords.png" />
</p>
</div>

<p>
所谓映射（Map），需要指定三角形每个顶点各自对应纹理的哪个部分。每个顶点都会关联一个纹理坐标，用于标明从纹理采样点。纹理坐标起于左下角的(0,0)，终于右上角的(1,1)。设定之后，图形的其他位置会做对应的插值。
图形硬件只认识纹理格式，而平时我们见的图片一般是png,jpg之类的图像格式。所以要使用纹理，首先要将图像文件加载，解析并生成纹理。针对图像文件的加载解析，可以参考开源的图像库，或者自己写。移动端可以直接使用系统提供的库。
图像文件经过加载解析后变成原始的图像数据，然后通过OpenGL API将数据生成纹理。最终通过shader做纹理映射。（记得生成纹理之后，将加载进来的图像数据释放）
</p>

<p>
OpenGL中主要的纹理相关API有 <code>glGenTextures</code>, <code>glBindTexture</code>, <code>glTexParameter*</code>, <code>glTexImage2D</code> 。分别用于生成、绑定、设参数、创建纹理数据。然后在shader中有对应的 <b>sampler</b> 表示一个纹理单元，通过 <code>glUniform*</code> 将纹理对象和纹理单元绑定起来，这样shader中就可以使用纹理数据了。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">vs</span>
<span style="color: #bc6ec5;">#version</span> <span style="color: #a45bad;">330</span> core
layout <span style="color: #4f97d7;">(</span>location = <span style="color: #a45bad;">0</span><span style="color: #4f97d7;">)</span> in <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">position</span>;
layout <span style="color: #4f97d7;">(</span>location = <span style="color: #a45bad;">1</span><span style="color: #4f97d7;">)</span> in <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">color</span>;
layout <span style="color: #4f97d7;">(</span>location = <span style="color: #a45bad;">2</span><span style="color: #4f97d7;">)</span> in <span style="color: #ce537a; font-weight: bold;">vec2</span> <span style="color: #7590db;">texCoord</span>;

out <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">ourColor</span>;
out <span style="color: #ce537a; font-weight: bold;">vec2</span> <span style="color: #7590db;">TexCoord</span>;

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">main</span><span style="color: #4f97d7;">()</span>
<span style="color: #4f97d7;">{</span>
    gl_Position = vec4<span style="color: #bc6ec5;">(</span>position, <span style="color: #a45bad;">1.0f</span><span style="color: #bc6ec5;">)</span>;
    ourColor = color;
    TexCoord = texCoord;
<span style="color: #4f97d7;">}</span>
</pre>
</div>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">fs</span>
<span style="color: #bc6ec5;">#version</span> <span style="color: #a45bad;">330</span> core
in <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">ourColor</span>;
in <span style="color: #ce537a; font-weight: bold;">vec2</span> <span style="color: #7590db;">TexCoord</span>;

out <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">color</span>;

uniform <span style="color: #ce537a; font-weight: bold;">sampler2D</span> <span style="color: #7590db;">ourTexture</span>;

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">main</span><span style="color: #4f97d7;">()</span>
<span style="color: #4f97d7;">{</span>
    color = texture<span style="color: #bc6ec5;">(</span>ourTexture, TexCoord<span style="color: #bc6ec5;">)</span>;
<span style="color: #4f97d7;">}</span>
</pre>
</div>

<p>
OpenGL至少保证可同时使用16个纹理单元，每个纹理单元对应一张纹理，即使说可以同时使用至少16张纹理。这样在着色器中可以做常见的多纹理混合效果。
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline24" class="outline-2">
<h2 id="orgheadline24">Main Loop</h2>
<div class="outline-text-2" id="text-orgheadline24">
<p>
<b>游戏循环</b> 应该是游戏程序与其他应用程序最大的区别。普通应用一般是事件驱动或者消息驱动，即接收到事件（消息）后才有反馈，而游戏循环是 <b>处理消息但不等待消息</b> ，始终运行。
最基本的游戏循环包括 <b>游戏更新</b> 和 <b>游戏渲染</b> 。最直接的写法如下：
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #4f97d7; font-weight: bold;">while</span><span style="color: #4f97d7;">(</span><span style="color: #a45bad;">true</span><span style="color: #4f97d7;">){</span>
    game_update<span style="color: #bc6ec5;">()</span>;
    game_render<span style="color: #bc6ec5;">()</span>;
<span style="color: #4f97d7;">}</span>
</pre>
</div>

<p>
update负责让游戏逻辑（数据）向前计算一步（比如AI和物理计算），render负责将当前游戏状态渲染并展示给玩家。将游戏看作一个世界，update直接影响这个世界运行的快慢，而render出来的结果只不过是这个世界某一时刻的快照。
</p>

<p>
上述写法表达的意思是， <b>有多快跑多快</b> 。而具体的快慢取决于update和render的复杂度加上目标机器的牛逼程度。表现出来的效果就是渣机在慢动作，神机快的看不清。这显然影响了正确性。
</p>

<p>
理想的游戏循环应该是硬件无关的，硬件的能力不能影响游戏update的速率，最多影响render出来的流畅性。 就是所谓的 <b>定时update，变时render</b> 
</p>


<div class="figure">
<p><img src="./images/update_render1.png" alt="update_render1.png" />
</p>
</div>



<div class="org-src-container">

<pre class="src src-c++"><span style="color: #ce537a; font-weight: bold;">double</span> <span style="color: #7590db;">previous</span> = getCurrentTime<span style="color: #4f97d7;">()</span>;
<span style="color: #ce537a; font-weight: bold;">double</span> <span style="color: #7590db;">lag</span> = <span style="color: #a45bad;">0.0</span>;
<span style="color: #4f97d7; font-weight: bold;">while</span> <span style="color: #4f97d7;">(</span><span style="color: #a45bad;">true</span><span style="color: #4f97d7;">){</span>
    <span style="color: #ce537a; font-weight: bold;">double</span> <span style="color: #7590db;">current</span> = getCurrentTime<span style="color: #bc6ec5;">()</span>;
    <span style="color: #ce537a; font-weight: bold;">double</span> <span style="color: #7590db;">elapsed</span> = current - previous;
    previous = current;
    lag += elapsed;
    processInput<span style="color: #bc6ec5;">()</span>;
    <span style="color: #4f97d7; font-weight: bold;">while</span> <span style="color: #bc6ec5;">(</span>lag &gt;= MS_PER_UPDATE<span style="color: #bc6ec5;">){</span>
        update<span style="color: #2d9574;">()</span>;
        lag -= MS_PER_UPDATE;
    <span style="color: #bc6ec5;">}</span>
    render<span style="color: #bc6ec5;">(</span>lag / MS_PER_UPDATE<span style="color: #bc6ec5;">)</span>;
<span style="color: #4f97d7;">}</span>
</pre>
</div>



<p>
每一个循环开始，通过两次循环之间的差值，计算出游戏时间落后现实时间的差值lag。然后通过内部循环，以固定间隔做update，追上现实时间，然后渲染输出并进入下一个循环。上述的 <b>MS<sub>PER</sub><sub>UPDATE</sub></b> 即是所谓的 <b>固定update间隔</b> ，这个间隔越短，追赶次数越多；间隔越大，跳帧越明显。理论上这个值小于16ms（60FPS)，但要保证大于update函数本身执行的时间（否则永远追不上现实时间，所以为了保证不卡死，可以设一个内部循环最大值）。
</p>



<div class="figure">
<p><img src="./images/update_render2.png" alt="update_render2.png" />
</p>
</div>

<p>
我们以固定的频率进行update，render的时间点不总是和update同步的。此时，render要保证平滑流畅，就不能直接使用前后任意update下的状态值，而是应该取对应的差值。比如，一颗高速的子弹，上一个update下，位于（0,0），下一个update下将在（100,0），而在两者之间需要渲染一帧画面出来，那子弹应该在哪里呢？答案就是取两者之间的差值。虽然实际上子弹还未update到该位置，render出来的位置属于 <b>预测</b> 点，可能这个预测点是错误的，但为了平滑度与流畅度，这点“视觉错误”可以接受。 
</p>

<div class="org-src-container">

<pre class="src src-c++">render<span style="color: #4f97d7;">(</span>lag / MS_PER_UPDATE<span style="color: #4f97d7;">)</span>
</pre>
</div>

<p>
这里我们将它除以MS<sub>PER</sub><sub>UPDATE是为了将值标准化</sub>。这样传入render()的值将在0(恰好在前一帧)到1(恰好在后一帧)之间(忽略更新时间步长)。通过这一方法，渲染引擎无需担心帧率。它仅仅处理0-1值之间的情况。
</p>

<p>
下面给出unity的主循环流程图：感受下成熟引擎的做法。
</p>


<div class="figure">
<p><img src="./images/monobehaviour_flowchart.png" alt="monobehaviour_flowchart.png" />
</p>
</div>


<p>
还可以看下ejoy2d的做法：
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">window.c </span><span style="color: #2aa1ae; background-color: #292e34;">*/</span>
<span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">Loop until the user closes the window </span><span style="color: #2aa1ae; background-color: #292e34;">*/</span>
<span style="color: #4f97d7; font-weight: bold;">while</span><span style="color: #4f97d7;">(</span><span style="color: #a45bad;">!</span>glfwWindowShouldClose<span style="color: #bc6ec5;">(</span>window<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span> <span style="color: #4f97d7;">{</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">update frame</span>
  <span style="color: #ce537a; font-weight: bold;">uint32_t</span> <span style="color: #7590db;">current</span> = _gettime<span style="color: #bc6ec5;">()</span>;
  <span style="color: #4f97d7; font-weight: bold;">if</span><span style="color: #bc6ec5;">(</span>current - timestamp &gt;= UPDATE_INTERVAL<span style="color: #bc6ec5;">)</span> <span style="color: #bc6ec5;">{</span>
    timestamp = current;
    ejoy2d_win_update<span style="color: #2d9574;">()</span>;
    ejoy2d_win_frame<span style="color: #2d9574;">()</span>;
  <span style="color: #bc6ec5;">}</span>

  <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">Swap front and back buffers </span><span style="color: #2aa1ae; background-color: #292e34;">*/</span>
  glfwSwapBuffers<span style="color: #bc6ec5;">(</span>window<span style="color: #bc6ec5;">)</span>;

  <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">Poll for and process events </span><span style="color: #2aa1ae; background-color: #292e34;">*/</span>
  glfwPollEvents<span style="color: #bc6ec5;">()</span>;
<span style="color: #4f97d7;">}</span>
</pre>
</div>


<div class="org-src-container">

<pre class="src src-c"><span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">winfw.c </span><span style="color: #2aa1ae; background-color: #292e34;">*/</span>
<span style="color: #ce537a; font-weight: bold;">void</span>
<span style="color: #bc6ec5; font-weight: bold;">ejoy2d_win_update</span><span style="color: #4f97d7;">()</span> <span style="color: #4f97d7;">{</span>
    ejoy2d_game_update<span style="color: #bc6ec5;">(</span>G-&gt;game, <span style="color: #a45bad;">0.01f</span><span style="color: #bc6ec5;">)</span>;
<span style="color: #4f97d7;">}</span>

<span style="color: #ce537a; font-weight: bold;">void</span>
<span style="color: #bc6ec5; font-weight: bold;">ejoy2d_win_frame</span><span style="color: #4f97d7;">()</span> <span style="color: #4f97d7;">{</span>
    ejoy2d_game_drawframe<span style="color: #bc6ec5;">(</span>G-&gt;game<span style="color: #bc6ec5;">)</span>;
<span style="color: #4f97d7;">}</span>
</pre>
</div>


<div class="org-src-container">

<pre class="src src-c"><span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">void</span>
<span style="color: #bc6ec5; font-weight: bold;">logic_frame</span><span style="color: #4f97d7;">(</span><span style="color: #ce537a; font-weight: bold;">lua_State</span> *<span style="color: #7590db;">L</span><span style="color: #4f97d7;">)</span> <span style="color: #4f97d7;">{</span>
    lua_pushvalue<span style="color: #bc6ec5;">(</span>L, UPDATE_FUNCTION<span style="color: #bc6ec5;">)</span>;
    call<span style="color: #bc6ec5;">(</span>L, <span style="color: #a45bad;">0</span>, <span style="color: #a45bad;">0</span><span style="color: #bc6ec5;">)</span>;
    lua_settop<span style="color: #bc6ec5;">(</span>L, TOP_FUNCTION<span style="color: #bc6ec5;">)</span>;
<span style="color: #4f97d7;">}</span>

<span style="color: #ce537a; font-weight: bold;">void</span>
<span style="color: #bc6ec5; font-weight: bold;">ejoy2d_game_update</span><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">game</span> *<span style="color: #7590db;">G</span>, <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">time</span><span style="color: #4f97d7;">)</span> <span style="color: #4f97d7;">{</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #bc6ec5;">(</span>G-&gt;logic_time == <span style="color: #a45bad;">0</span><span style="color: #bc6ec5;">)</span> <span style="color: #bc6ec5;">{</span>
        G-&gt;real_time = <span style="color: #a45bad;">1.0f</span>/LOGIC_FRAME;
    <span style="color: #bc6ec5;">}</span> <span style="color: #4f97d7; font-weight: bold;">else</span> <span style="color: #bc6ec5;">{</span>
        G-&gt;real_time += time;
    <span style="color: #bc6ec5;">}</span>
    <span style="color: #4f97d7; font-weight: bold;">while</span> <span style="color: #bc6ec5;">(</span>G-&gt;logic_time &lt; G-&gt;real_time<span style="color: #bc6ec5;">)</span> <span style="color: #bc6ec5;">{</span>
        logic_frame<span style="color: #2d9574;">(</span>G-&gt;L<span style="color: #2d9574;">)</span>;
        G-&gt;logic_time += <span style="color: #a45bad;">1.0f</span>/LOGIC_FRAME;
    <span style="color: #bc6ec5;">}</span>
<span style="color: #4f97d7;">}</span>

<span style="color: #ce537a; font-weight: bold;">void</span>
<span style="color: #bc6ec5; font-weight: bold;">ejoy2d_game_drawframe</span><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">game</span> *<span style="color: #7590db;">G</span><span style="color: #4f97d7;">)</span> <span style="color: #4f97d7;">{</span>
    reset_drawcall_count<span style="color: #bc6ec5;">()</span>;
    lua_pushvalue<span style="color: #bc6ec5;">(</span>G-&gt;L, DRAWFRAME_FUNCTION<span style="color: #bc6ec5;">)</span>;
    call<span style="color: #bc6ec5;">(</span>G-&gt;L, <span style="color: #a45bad;">0</span>, <span style="color: #a45bad;">0</span><span style="color: #bc6ec5;">)</span>;
    lua_settop<span style="color: #bc6ec5;">(</span>G-&gt;L, TOP_FUNCTION<span style="color: #bc6ec5;">)</span>;
    shader_flush<span style="color: #bc6ec5;">()</span>;
    label_flush<span style="color: #bc6ec5;">()</span>;
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">int cnt = drawcall_count();</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">printf("-&gt; %d\n", cnt);</span>
<span style="color: #4f97d7;">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline25" class="outline-2">
<h2 id="orgheadline25">Sprite</h2>
<div class="outline-text-2" id="text-orgheadline25">
<p>
我们使用 <b>Sprite</b> 来表示一个2D渲染对象。特意注明2D，是因为渲染Sprite不需要像3D渲染那样根据摄像机的视角计算出透视坐标和光照来展现三维物体的表面。Sprite只需要最基本的 <code>position</code> <code>scale</code> <code>rotation</code> <code>shader</code> 即可渲染在屏幕上（就像之前我们做的所有渲染尝试）。
</p>
</div>

<div id="outline-container-orgheadline26" class="outline-3">
<h3 id="orgheadline26">2D投影</h3>
<div class="outline-text-3" id="text-orgheadline26">
<p>
OpenGL本身是个3D图形API，其所有的概念都是针对三维世界的。但我们能接收到的图像输出目前只有二维（比如显示器）。所以要展现我们在三维世界创建的游戏世界就需要投影到二维平面上面。（局部空间-&gt;世界空间-&gt;观察空间-&gt;裁剪空间(标准化设备坐标)-&gt;屏幕空间）这些坐标系的变换都是通过矩阵变换而来。
针对二维渲染，我们不需要透视处理，所以使用正交投影（没有近大远小的视觉感受）。
</p>

<p>
<img src="./images/orthographic_frustum.png" alt="orthographic_frustum.png" />  <img src="./images/perspective_frustum.png" alt="perspective_frustum.png" />
</p>


<div class="org-src-container">

<pre class="src src-c++"><span style="color: #2aa1ae; background-color: #292e34;">/*</span>
<span style="color: #2aa1ae; background-color: #292e34;">*&#21069;&#20004;&#20010;&#21442;&#25968;&#25351;&#23450;&#20102;&#24179;&#25130;&#22836;&#20307;&#30340;&#24038;&#21491;&#22352;&#26631;&#65292;&#31532;&#19977;&#21644;&#31532;&#22235;&#21442;&#25968;&#25351;&#23450;&#20102;&#24179;&#25130;&#22836;&#20307;&#30340;&#24213;&#37096;&#21644;&#39030;&#37096;&#12290;</span>
<span style="color: #2aa1ae; background-color: #292e34;">*&#36890;&#36807;&#36825;&#22235;&#20010;&#21442;&#25968;&#25105;&#20204;&#23450;&#20041;&#20102;&#36817;&#24179;&#38754;&#21644;&#36828;&#24179;&#38754;&#30340;&#22823;&#23567;&#65292;&#28982;&#21518;&#31532;&#20116;&#21644;&#31532;&#20845;&#20010;&#21442;&#25968;&#21017;&#23450;&#20041;&#20102;&#36817;&#24179;&#38754;&#21644;&#36828;&#24179;&#38754;&#30340;&#36317;&#31163;&#12290;</span>
<span style="color: #2aa1ae; background-color: #292e34;">*&#36825;&#20010;&#25237;&#24433;&#30697;&#38453;&#20250;&#23558;&#22788;&#20110;&#36825;&#20123;x&#65292;y&#65292;z&#20540;&#33539;&#22260;&#20869;&#30340;&#22352;&#26631;&#21464;&#25442;&#20026;&#26631;&#20934;&#21270;&#35774;&#22791;&#22352;&#26631;&#12290;</span>
<span style="color: #2aa1ae; background-color: #292e34;">*/</span>
<span style="color: #a45bad;">glm</span>::<span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">projection</span> = <span style="color: #a45bad;">glm</span>::ortho<span style="color: #4f97d7;">(</span><span style="color: #a45bad;">0.0f</span>, <span style="color: #a45bad;">800.0f</span>, <span style="color: #a45bad;">600.0f</span>, <span style="color: #a45bad;">0.0f</span>, -<span style="color: #a45bad;">1.0f</span>, <span style="color: #a45bad;">1.0f</span><span style="color: #4f97d7;">)</span>;
</pre>
</div>


<div class="figure">
<p><img src="./images/projection.png" alt="projection.png" />
</p>
</div>

<p>
设定这样的正交投影矩阵后，世界空间坐标就直接与最终的屏幕空间坐标对应。这样我们在开发2D游戏时，直接指定顶点坐标为屏幕上的像素坐标，相对来讲就直观许多。同时，我们所使用的顶点着色器也要做相应的改变，每一个顶点的位置都要经过投影矩阵变换一下。
</p>

<div class="org-src-container">

<pre class="src src-c++">gl_Position = projection * model * vec4<span style="color: #4f97d7;">(</span>vertex.xy, <span style="color: #a45bad;">0.0</span>, <span style="color: #a45bad;">1.0</span><span style="color: #4f97d7;">)</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline27" class="outline-3">
<h3 id="orgheadline27">SpriteRenderer</h3>
<div class="outline-text-3" id="text-orgheadline27">
<p>
我们定义一个 <b>SpriteRenderer</b> 类来表示2D渲染对象。一般来讲，一个具备渲染能力的2D对象需要的属性有 <code>position</code> <code>size</code> <code>rotate</code> <code>color</code> <code>shader</code>, <code>texture</code> 可选（没有纹理的sprite），定义如下：
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">SpriteRenderer</span> <span style="color: #4f97d7;">{</span>
    <span style="color: #a45bad;">glm</span>::<span style="color: #ce537a; font-weight: bold;">vec2</span> <span style="color: #7590db;">position</span>;
    <span style="color: #a45bad;">glm</span>::<span style="color: #ce537a; font-weight: bold;">vec2</span> <span style="color: #7590db;">size</span>;
    <span style="color: #a45bad;">glm</span>::<span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">color</span>;
    <span style="color: #ce537a; font-weight: bold;">GLfloat</span> <span style="color: #7590db;">rotate</span>;

    <span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">vao</span>;
    <span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">shader</span>;
    <span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">texture2d</span>;

<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #bc6ec5; font-weight: bold;">SpriteRenderer</span><span style="color: #bc6ec5;">(</span><span style="color: #a45bad;">glm</span>::<span style="color: #ce537a; font-weight: bold;">vec2</span> <span style="color: #7590db;">p</span> = <span style="color: #a45bad;">glm</span>::<span style="color: #7590db;">vec2</span><span style="color: #2d9574;">(</span><span style="color: #a45bad;">0.0f</span><span style="color: #2d9574;">)</span>,
                   <span style="color: #a45bad;">glm</span>::<span style="color: #ce537a; font-weight: bold;">vec2</span> <span style="color: #7590db;">s</span> = <span style="color: #a45bad;">glm</span>::<span style="color: #7590db;">vec2</span><span style="color: #2d9574;">(</span><span style="color: #a45bad;">1.0f</span><span style="color: #2d9574;">)</span>,
                   <span style="color: #7590db;">GLfloat</span> r = <span style="color: #a45bad;">0.0f</span>,
                   <span style="color: #a45bad;">glm</span>::<span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">c</span> = <span style="color: #a45bad;">glm</span>::<span style="color: #7590db;">vec3</span><span style="color: #2d9574;">(</span><span style="color: #a45bad;">1.0f</span><span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span>;
    ~<span style="color: #bc6ec5; font-weight: bold;">SpriteRenderer</span><span style="color: #bc6ec5;">()</span>;
    <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">draw</span><span style="color: #bc6ec5;">()</span>;

    <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">other method */</span>

<span style="color: #4f97d7;">}</span>;
</pre>
</div>


<p>
SpriteRenderer本质上就是由两个三角形构成的矩形块。所以回想前面我们做过的渲染实验。一个sprite的构造与渲染其实就是把之前我们写过的代码好好封装一下。同时，为了更好的表示物体的空间属性和转换，采用了 <b>向量（vector</b> 和 <b>矩阵（matrix）</b> 。简言之，向量与矩阵都是多维的，向量用来表示位置与方向，矩阵用来表示转换。这里，我直接用了 <code>glm</code> 这个数学库，自己实现一下也很简单。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #a45bad;">SpriteRenderer</span>::<span style="color: #bc6ec5; font-weight: bold;">SpriteRenderer</span><span style="color: #4f97d7;">(</span><span style="color: #a45bad;">glm</span>::<span style="color: #ce537a; font-weight: bold;">vec2</span> <span style="color: #7590db;">p</span>, <span style="color: #a45bad;">glm</span>::<span style="color: #ce537a; font-weight: bold;">vec2</span> <span style="color: #7590db;">s</span>, <span style="color: #7590db;">GLfloat</span> r, <span style="color: #a45bad;">glm</span>::<span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">c</span><span style="color: #4f97d7;">)</span>:
    position<span style="color: #4f97d7;">(</span>p<span style="color: #4f97d7;">)</span>,
    size<span style="color: #4f97d7;">(</span>s<span style="color: #4f97d7;">)</span>,
    rotate<span style="color: #4f97d7;">(</span>r<span style="color: #4f97d7;">)</span>,
    color<span style="color: #4f97d7;">(</span>c<span style="color: #4f97d7;">)</span>,
    vao<span style="color: #4f97d7;">(</span><span style="color: #a45bad;">0</span><span style="color: #4f97d7;">)</span>,
    shader<span style="color: #4f97d7;">(</span><span style="color: #a45bad;">0</span><span style="color: #4f97d7;">)</span>,
    texture2d<span style="color: #4f97d7;">(</span><span style="color: #a45bad;">0</span><span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">{</span>
    <span style="color: #ce537a; font-weight: bold;">GLuint</span> <span style="color: #7590db;">vbo</span>;
    <span style="color: #ce537a; font-weight: bold;">GLfloat</span> <span style="color: #7590db;">vertices</span><span style="color: #bc6ec5;">[]</span> = <span style="color: #bc6ec5;">{</span>
        <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">pos        //texture</span>
        <span style="color: #a45bad;">0.0f</span>, <span style="color: #a45bad;">1.0f</span>,  <span style="color: #a45bad;">0.0f</span>, <span style="color: #a45bad;">1.0f</span>,
        <span style="color: #a45bad;">1.0f</span>, <span style="color: #a45bad;">0.0f</span>,  <span style="color: #a45bad;">1.0f</span>, <span style="color: #a45bad;">0.0f</span>,
        <span style="color: #a45bad;">0.0f</span>, <span style="color: #a45bad;">0.0f</span>,  <span style="color: #a45bad;">0.0f</span>, <span style="color: #a45bad;">0.0f</span>,

        <span style="color: #a45bad;">0.0f</span>, <span style="color: #a45bad;">1.0f</span>,  <span style="color: #a45bad;">0.0f</span>, <span style="color: #a45bad;">1.0f</span>,
        <span style="color: #a45bad;">1.0f</span>, <span style="color: #a45bad;">1.0f</span>,  <span style="color: #a45bad;">1.0f</span>, <span style="color: #a45bad;">1.0f</span>,
        <span style="color: #a45bad;">1.0f</span>, <span style="color: #a45bad;">0.0f</span>,  <span style="color: #a45bad;">1.0f</span>, <span style="color: #a45bad;">0.0f</span>,
    <span style="color: #bc6ec5;">}</span>;

    glGenVertexArrays<span style="color: #bc6ec5;">(</span><span style="color: #a45bad;">1</span>, &amp;<span style="color: #4f97d7; font-weight: bold;">this</span>-&gt;vao<span style="color: #bc6ec5;">)</span>;
    glGenBuffers<span style="color: #bc6ec5;">(</span><span style="color: #a45bad;">1</span>, &amp;vbo<span style="color: #bc6ec5;">)</span>;

    glBindBuffer<span style="color: #bc6ec5;">(</span>GL_ARRAY_BUFFER, vbo<span style="color: #bc6ec5;">)</span>;
    glBufferData<span style="color: #bc6ec5;">(</span>GL_ARRAY_BUFFER, <span style="color: #4f97d7; font-weight: bold;">sizeof</span><span style="color: #2d9574;">(</span>vertices<span style="color: #2d9574;">)</span>, vertices, GL_STATIC_DRAW<span style="color: #bc6ec5;">)</span>;

    glBindVertexArray<span style="color: #bc6ec5;">(</span><span style="color: #4f97d7; font-weight: bold;">this</span>-&gt;vao<span style="color: #bc6ec5;">)</span>;
    glEnableVertexAttribArray<span style="color: #bc6ec5;">(</span><span style="color: #a45bad;">0</span><span style="color: #bc6ec5;">)</span>;
    glVertexAttribPointer<span style="color: #bc6ec5;">(</span><span style="color: #a45bad;">0</span>, <span style="color: #a45bad;">4</span>, GL_FLOAT, GL_FALSE, <span style="color: #a45bad;">4</span>*<span style="color: #4f97d7; font-weight: bold;">sizeof</span><span style="color: #2d9574;">(</span>GLfloat<span style="color: #2d9574;">)</span>, <span style="color: #2d9574;">(</span><span style="color: #ce537a; font-weight: bold;">GLfloat</span>*<span style="color: #2d9574;">)</span><span style="color: #a45bad;">0</span><span style="color: #bc6ec5;">)</span>;
    glBindBuffer<span style="color: #bc6ec5;">(</span>GL_ARRAY_BUFFER, <span style="color: #a45bad;">0</span><span style="color: #bc6ec5;">)</span>;
    glBindVertexArray<span style="color: #bc6ec5;">(</span><span style="color: #a45bad;">0</span><span style="color: #bc6ec5;">)</span>;
<span style="color: #4f97d7;">}</span>
</pre>
</div>

<p>
这里顶点数据里面，我们根据2D图形的特殊性，pos只要了2个分量，丢弃了顶点color，保留了纹理坐标。这样我们可以将一个顶点的数据塞进一个 vector4 里面，节约内存。（为什么丢弃顶点颜色呢？因为2D图形很少做光照计算，其颜色值基本取自对应的纹素值；再者，即使有需要顶点颜色的时候，也可以在通过直接给shader传值来间接实现）
</p>

<p>
同理，sprite的渲染也是将之前零散的代码聚合封装一下。我们设置的pos，size和rotate实质上就是在变换sprite。比如设置pos为（10,10），实际上是将sprite从（0,0）移动到（10,10），设置size则等同于缩放。如此，每一次sprite的绘制，都会经历坐标变换，着色渲染（跑一遍渲染流水线）。
</p>

<p>
针对三维空间中物体的变换，变换的轴都是固定的。而矩阵乘法不满足交换律（变换顺序不同，结果不同），所以符合期望的变换顺序 <b>缩放、旋转、平移</b> 。（由于矩阵乘法是从右往左的，所以写代码的时候又要反过来写）
</p>



<div class="figure">
<p><img src="./images/transform.png" alt="transform.png" />
</p>
</div>


<p>
针对二维旋转，我们默认是以左上角为原点的，旋转操作可能不是一般想要的那种旋转，所以这里做了一点额外的操作，在旋转前将origin移到四边形的中心，再进行旋转，之后再移回去。
</p>


<div class="figure">
<p><img src="./images/rotation-origin.png" alt="rotation-origin.png" />
</p>
</div>


<p>
如此，SpriteRenderer的绘制代码就差不多写出来了：
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #a45bad;">SpriteRenderer</span>::<span style="color: #bc6ec5; font-weight: bold;">draw</span><span style="color: #4f97d7;">()</span>
<span style="color: #4f97d7;">{</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">create model-view matrix</span>
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">(transformations are: scale happens first, then rotation and then finall translation happens; reversed order)</span>
    <span style="color: #a45bad;">glm</span>::<span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">model</span>;
    model = <span style="color: #a45bad;">glm</span>::translate<span style="color: #bc6ec5;">(</span>model, <span style="color: #a45bad;">glm</span>::vec3<span style="color: #2d9574;">(</span><span style="color: #4f97d7; font-weight: bold;">this</span>-&gt;position, <span style="color: #a45bad;">0.0f</span><span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span>;

    model = <span style="color: #a45bad;">glm</span>::translate<span style="color: #bc6ec5;">(</span>model, <span style="color: #a45bad;">glm</span>::vec3<span style="color: #2d9574;">(</span><span style="color: #a45bad;">0.5f</span>*<span style="color: #4f97d7; font-weight: bold;">this</span>-&gt;size.x, <span style="color: #a45bad;">0.5f</span>*<span style="color: #4f97d7; font-weight: bold;">this</span>-&gt;size.y, <span style="color: #a45bad;">0.0f</span><span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span>;
    model = <span style="color: #a45bad;">glm</span>::rotate<span style="color: #bc6ec5;">(</span>model, <span style="color: #4f97d7; font-weight: bold;">this</span>-&gt;rotate, <span style="color: #a45bad;">glm</span>::vec3<span style="color: #2d9574;">(</span><span style="color: #a45bad;">0.0f</span>, <span style="color: #a45bad;">0.0f</span>, <span style="color: #a45bad;">1.0f</span><span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span>;
    model = <span style="color: #a45bad;">glm</span>::translate<span style="color: #bc6ec5;">(</span>model, <span style="color: #a45bad;">glm</span>::vec3<span style="color: #2d9574;">(</span>-<span style="color: #a45bad;">0.5f</span>*<span style="color: #4f97d7; font-weight: bold;">this</span>-&gt;size.x,  -<span style="color: #a45bad;">0.5f</span>*<span style="color: #4f97d7; font-weight: bold;">this</span>-&gt;size.y, <span style="color: #a45bad;">0.0f</span><span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span>;

    model = <span style="color: #a45bad;">glm</span>::scale<span style="color: #bc6ec5;">(</span>model, <span style="color: #a45bad;">glm</span>::vec3<span style="color: #2d9574;">(</span><span style="color: #4f97d7; font-weight: bold;">this</span>-&gt;size, <span style="color: #a45bad;">1.0f</span><span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span>;

    glUseProgram<span style="color: #bc6ec5;">(</span><span style="color: #4f97d7; font-weight: bold;">this</span>-&gt;shader<span style="color: #bc6ec5;">)</span>;
    glUniformMatrix4fv<span style="color: #bc6ec5;">(</span>glGetUniformLocation<span style="color: #2d9574;">(</span><span style="color: #4f97d7; font-weight: bold;">this</span>-&gt;shader, <span style="color: #2d9574;">"model"</span><span style="color: #2d9574;">)</span>, <span style="color: #a45bad;">1</span>, GL_FALSE, <span style="color: #a45bad;">glm</span>::value_ptr<span style="color: #2d9574;">(</span>model<span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span>;
    glUniform3f<span style="color: #bc6ec5;">(</span>glGetUniformLocation<span style="color: #2d9574;">(</span><span style="color: #4f97d7; font-weight: bold;">this</span>-&gt;shader, <span style="color: #2d9574;">"scolor"</span><span style="color: #2d9574;">)</span>, <span style="color: #4f97d7; font-weight: bold;">this</span>-&gt;color.x, <span style="color: #4f97d7; font-weight: bold;">this</span>-&gt;color.y, <span style="color: #4f97d7; font-weight: bold;">this</span>-&gt;color.z<span style="color: #bc6ec5;">)</span>;

    <span style="color: #4f97d7; font-weight: bold;">if</span><span style="color: #bc6ec5;">(</span><span style="color: #4f97d7; font-weight: bold;">this</span>-&gt;texture2d != <span style="color: #a45bad;">0</span><span style="color: #bc6ec5;">){</span>
        glActiveTexture<span style="color: #2d9574;">(</span>GL_TEXTURE0<span style="color: #2d9574;">)</span>;
        glBindTexture<span style="color: #2d9574;">(</span>GL_TEXTURE_2D, <span style="color: #4f97d7; font-weight: bold;">this</span>-&gt;texture2d<span style="color: #2d9574;">)</span>;
        glUniform1i<span style="color: #2d9574;">(</span>glGetUniformLocation<span style="color: #67b11d;">(</span><span style="color: #4f97d7; font-weight: bold;">this</span>-&gt;shader, <span style="color: #2d9574;">"image"</span><span style="color: #67b11d;">)</span>, <span style="color: #a45bad;">0</span><span style="color: #2d9574;">)</span>;
    <span style="color: #bc6ec5;">}</span>

    glBindVertexArray<span style="color: #bc6ec5;">(</span><span style="color: #4f97d7; font-weight: bold;">this</span>-&gt;vao<span style="color: #bc6ec5;">)</span>;
    glDrawArrays<span style="color: #bc6ec5;">(</span>GL_TRIANGLES, <span style="color: #a45bad;">0</span>, <span style="color: #a45bad;">6</span><span style="color: #bc6ec5;">)</span>;
    glBindVertexArray<span style="color: #bc6ec5;">(</span><span style="color: #a45bad;">0</span><span style="color: #bc6ec5;">)</span>;
<span style="color: #4f97d7;">}</span>
</pre>
</div>

<p>
然后，模型变换完毕，最终送到shader中，通过投影矩阵将三维投影成二维。
</p>

<p>
因此，相应的shader也要做些改变。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #bc6ec5;">#version</span> <span style="color: #a45bad;">330</span> core
layout <span style="color: #4f97d7;">(</span>location = <span style="color: #a45bad;">0</span><span style="color: #4f97d7;">)</span> in <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">vertex</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&lt;vec2 position, vec2 texCoords&gt;</span>

out <span style="color: #ce537a; font-weight: bold;">vec2</span> <span style="color: #7590db;">TexCoords</span>;

uniform <span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">model</span>;
uniform <span style="color: #ce537a; font-weight: bold;">mat4</span> <span style="color: #7590db;">projection</span>;

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">main</span><span style="color: #4f97d7;">()</span>
<span style="color: #4f97d7;">{</span>
    TexCoords = vertex.zw;
    gl_Position = projection * model * vec4<span style="color: #bc6ec5;">(</span>vertex.xy, <span style="color: #a45bad;">0.0</span>, <span style="color: #a45bad;">1.0</span><span style="color: #bc6ec5;">)</span>;
<span style="color: #4f97d7;">}</span>
</pre>
</div>


<div class="org-src-container">

<pre class="src src-c++"><span style="color: #bc6ec5;">#version</span> <span style="color: #a45bad;">330</span> core
in <span style="color: #ce537a; font-weight: bold;">vec2</span> <span style="color: #7590db;">TexCoords</span>;
out <span style="color: #ce537a; font-weight: bold;">vec4</span> <span style="color: #7590db;">color</span>;

uniform <span style="color: #ce537a; font-weight: bold;">sampler2D</span> <span style="color: #7590db;">image</span>;
uniform <span style="color: #ce537a; font-weight: bold;">vec3</span> <span style="color: #7590db;">scolor</span>;

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">main</span><span style="color: #4f97d7;">()</span>
<span style="color: #4f97d7;">{</span>
    color = vec4<span style="color: #bc6ec5;">(</span>scolor, <span style="color: #a45bad;">1.0</span><span style="color: #bc6ec5;">)</span> * texture<span style="color: #bc6ec5;">(</span>image, TexCoords<span style="color: #bc6ec5;">)</span>;
<span style="color: #4f97d7;">}</span>
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: keyring</p>
<p class="date">Created: 2016-12-02 周五 14:51</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
